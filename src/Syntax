{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE TemplateHaskell #-}

module Syntax where

import Macros

type Pos = Int

type Symbol = String

data Var = SimpleVar Symbol Pos | FieldVar Var Symbol Pos | SubscriptVar Var Exp Pos
  deriving (Show, Eq)

data Exp
  = VarExp Var
  | NilExp
  | IntExp Int
  | StringExp String Pos
  | CallExp {func :: Symbol, args :: [Exp], pos :: Pos}
  | OpExp {left :: Exp, oper :: Oper, right :: Exp, pos :: Pos}
  | RecordExp {typ :: Symbol, fields :: [(Symbol, Exp, Pos)], pos :: Pos}
  | SeqExp [(Exp, Pos)]
  | AssignExp {var :: Var, exp :: Exp, pos :: Pos }
  | IfExp {test :: Exp, then' :: Exp, else' :: Maybe Exp, pos :: Pos }
  | WhileExp {test :: Exp, body :: Exp, pos :: Pos }
  | ForExp { varFor :: Symbol, escape :: Bool, lo :: Exp, hi :: Exp, body :: Exp, pos :: Pos }
  | BreakExp Pos
  | LetExp {decs :: [Dec], body :: Exp, pos :: Pos }
  | ArrayExp {typ :: Symbol, size :: Exp, init :: Exp, pos :: Pos }
  deriving (Show, Eq)

data Dec
  = FunctionDec [Fundec]
  | VarDec {name :: Symbol, escape :: Bool, typ :: Maybe (Symbol, Pos), init :: Exp, pos :: Pos}
  | TypeDec [(Symbol, Ty, Pos)]
  deriving (Show, Eq)

data Ty = NameTy Symbol Pos | RecordTy [Field] | ArrayTy Symbol Pos
  deriving (Show, Eq)

data Oper = PlusOp | MinusOp | TimesOp | DivideOp | EqOp | NeqOp | LtOp | LeOp | GtOp | GeOp
  deriving (Show, Eq)

data Field = Field {name :: Symbol, escape :: Bool, typ :: Symbol, pos :: Pos}
  deriving (Show, Eq)

data Fundec = Fundec {name :: Symbol, params :: [Field], resultTyp :: Maybe (Symbol, Pos), body :: Exp, pos :: Pos}
  deriving (Show, Eq)
