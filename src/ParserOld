{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DisambiguateRecordFields #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE TypeOperators #-}

module ParserOld () where

import Control.Applicative hiding (many, some)
import Data.Text (Text)
import Data.Void
import Syntax as S
import Util
import Text.Megaparsec
import Text.Megaparsec.Char
import qualified Text.Megaparsec.Char.Lexer as L

type Parser = Parsec Void String

a $> b = b <$ a

fmap2 = fmap . fmap

lexeme, brackets, parens, squares :: Parser a -> Parser a
lexeme = L.lexeme space
brackets = between (char '(') (char ')')
parens = between (char '{') (char '}')
squares = between (char '[') (char ']')

sepBy2 p sep = do
  first <- p
  sep
  rest <- sepBy1 p sep
  pure $ first:rest

parseStrLit :: Parser String
parseStrLit = lexeme $ do
  char '\"'
  strLit <- many $ alphaNumChar <|> spaceChar
  char '\"'
  pure strLit

parseIdent :: Parser String
parseIdent = lexeme $ (pure <$> letterChar) <> many (alphaNumChar <|> char '_')

stringL :: String -> Parser String
stringL = lexeme . string

charL :: Char -> Parser Char
charL = lexeme . char

dummy = 0

parseTyId :: Parser Ty
parseTyId = (\s -> NameTy s dummy) <$> parseIdent
parseArrayTy = (\s -> ArrayTy s dummy) <$> (stringL "array" *> stringL "of" *> parseIdent)

parseTyField :: Parser Field
parseTyField = do
  ident <- parseIdent
  charL ':'
  typeId <- parseIdent
  pure $ Field {name = ident, escape = False, typ = typeId, pos = dummy}

parseTyFields = sepBy parseTyField (charL ',')

parseTy :: Parser Ty
parseTy =
  choice [parseArrayTy, fmap RecordTy $ parens parseTyFields, parseTyId]

parseTydec :: Parser (Symbol, Ty, S.Pos)
parseTydec = do
  stringL "type"
  typeId <- parseIdent
  charL '='
  typ <- parseTy
  pure (typeId, typ, dummy)

parseVar :: Parser Var
parseVar =
  (liftA2 (\arr expression -> SubscriptVar arr expression dummy) parseVar (squares parseExp))
  <|> (liftA2 (\record field -> FieldVar record field dummy) parseVar (charL '.' *> parseIdent))
  <|> ((\s -> SimpleVar s dummy) <$> parseIdent)

parseWhile, parseFor, parseIfThenElse, parseIfThen, parseLet, parseArrayCreation :: Parser Exp
parseWhile = liftA2 (\t b -> WhileExp t b dummy) (stringL "while" *> parseExp) (stringL "do" *> parseExp)

parseFor = liftA4 (\s lo hi body -> ForExp s False lo hi body dummy)
  (stringL "for" *> parseIdent) (stringL ":=" *> parseExp) (stringL "to" *> parseExp) (stringL "do" *> parseExp)

parseIfThenElse = liftA3 (\t body elseBody -> IfExp t body (Just elseBody) dummy)
  (stringL "if" *> parseExp) (stringL "then" *> parseExp) (stringL "else" *> parseExp)

parseIfThen = liftA2 (\t body -> IfExp t body Nothing dummy) (stringL "if" *> parseExp) (stringL "then" *> parseExp)

parseLet = do
  stringL "let"
  decs <- some $ parseDec
  stringL "in"
  body <- parseExp
  stringL "end"
  pure $ LetExp decs body dummy

parseArrayCreation = liftA3 (\s size initValue -> ArrayExp s size initValue dummy)
  parseIdent (squares $ parseExp) (stringL "of" *> parseExp)

parseAssign, parseRecordExp, parseFunctionCall, parseOpExp :: Parser Exp
parseAssign = liftA2 (\lvalue expr -> AssignExp lvalue expr dummy) (parseVar <* stringL ":=") parseExp

parseRecordExp = liftA2 (\typ fields -> RecordExp typ fields dummy)
  parseIdent (parens $ sepBy help (charL ','))
  where help = liftA2 (\s value -> (s,value,dummy)) (parseIdent <* charL '=') parseExp

parseFunctionCall = liftA2 (\f args -> CallExp f args dummy)
  parseIdent (brackets $ sepBy parseExp (charL ','))

parseOpExp =
  foldr (\info p -> help info <|> p) empty operators
    where help (op,opSym) = liftA2 (\l r -> OpExp l op r dummy) (parseExp <* stringL opSym) parseExp
          operators = [(TimesOp, "*"), (DivideOp, "/"), (PlusOp, "+"), (MinusOp, "-"),
            (EqOp, "="), (LtOp, "<"), (NeqOp, "<>"), (GtOp, ">"), (LtOp, "<"), (GeOp, ">="), (LeOp, "<=")]

parseExp :: Parser Exp
parseExp =
  (stringL "nil" $> NilExp)
  <|> (stringL "break" $> BreakExp dummy)
  <|> (fmap SeqExp $ fmap2 (\x -> (x,dummy)) (parens $ sepBy2 parseExp (charL ';')))
  <|> parseWhile
  <|> parseFor
  <|> parseIfThenElse
  <|> parseIfThen
  <|> parseLet
  <|> ((\s -> StringExp s dummy) <$> parseStrLit)
  <|> (IntExp . read <$> some digitChar)
  <|> parseArrayCreation
  <|> parseFunctionCall
  <|> parseOpExp
  -- this shouldn't fail as there as at least 1 digit between 0 and 9
  <|> parseRecordExp
  <|> (VarExp <$> parseVar)
  <|> parseAssign
  <|> parens parseExp

parseVarDec :: Parser Dec
parseVarDec = do
  (liftA3 (\ident typ initial -> VarDec ident False (Just (typ, dummy)) initial dummy)
    (stringL "var" *> parseIdent) (charL ':' *> parseIdent) (stringL ":=" *> parseExp))
  <|> (liftA2 (\ident initial -> VarDec ident False Nothing initial dummy)
    (stringL "var" *> parseIdent) (stringL ":=" *> parseExp))

parseFunDec :: Parser Fundec
parseFunDec = do
  (liftA4 (\name params resultTyp expr -> Fundec name params (Just (resultTyp, dummy)) expr dummy)
    (stringL "function" *> parseIdent) (brackets parseTyFields) (charL ':' *> parseIdent) (stringL "=" *> parseExp))
  <|> (liftA3 (\name params expr -> Fundec name params Nothing expr dummy)
    (stringL "function" *> parseIdent) (brackets parseTyFields) (stringL "=" *> parseExp))

parseDec :: Parser Dec
parseDec = parseVarDec <|> (FunctionDec <$> sepBy1 parseFunDec (stringL ";;;")) <|>
  (TypeDec <$> (some parseTydec))

present (Left x) = errorBundlePretty x
present (Right x) = show $ x

useful parser stuff = present $ runParser parser "" stuff
