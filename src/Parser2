{-# LANGUAGE AllowAmbiguousTypes #-}
{-# LANGUAGE DisambiguateRecordFields #-}
{-# LANGUAGE FlexibleContexts #-}
{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE NoMonomorphismRestriction #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE FlexibleInstances #-}

module Parser2 () where

import Control.Applicative hiding (many, some)
import Data.Text (Text)
import Data.Void
import Syntax2 as S
import Util
import Text.Megaparsec
import Text.Megaparsec.Char
import Lexer as L
import qualified Data.Set as E

instance VisualStream [L.Token] where
  showTokens p = foldMap (\x -> ' ':show x)

type Parser = Parsec Void [L.Token]

a $> b = b <$ a

fmap2 = fmap . fmap

brackets, parens, squares :: Parser a -> Parser a
brackets = between (single LBracket) (single RBracket)
parens = between (single LBrace) (single RBrace)
squares = between (single LSquare) (single RSquare)

sepBy2 p sep = do
  first <- p
  sep
  rest <- sepBy1 p sep
  pure $ first:rest

parseIdent :: Parser String
parseIdent = token f E.empty
  where f (Ident s) = Just s
        f _ = Nothing

parseTy :: Parser Ty
parseTy = choice [fmap ArrayTy (chunk [Array,Of] *> parseIdent)]

present (Left x) = errorBundlePretty x
present (Right x) = show $ x

useful parser stuff = present $ runParser parser "" stuff
